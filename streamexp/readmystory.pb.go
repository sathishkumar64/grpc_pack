// Code generated by protoc-gen-go. DO NOT EDIT.
// source: readmystory.proto

package streamexp

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ReadStoryVO struct {
	Course               string   `protobuf:"bytes,1,opt,name=course,proto3" json:"course,omitempty"`
	TutorName            string   `protobuf:"bytes,2,opt,name=tutorName,proto3" json:"tutorName,omitempty"`
	Status               bool     `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadStoryVO) Reset()         { *m = ReadStoryVO{} }
func (m *ReadStoryVO) String() string { return proto.CompactTextString(m) }
func (*ReadStoryVO) ProtoMessage()    {}
func (*ReadStoryVO) Descriptor() ([]byte, []int) {
	return fileDescriptor_725931738025df9a, []int{0}
}

func (m *ReadStoryVO) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadStoryVO.Unmarshal(m, b)
}
func (m *ReadStoryVO) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadStoryVO.Marshal(b, m, deterministic)
}
func (m *ReadStoryVO) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadStoryVO.Merge(m, src)
}
func (m *ReadStoryVO) XXX_Size() int {
	return xxx_messageInfo_ReadStoryVO.Size(m)
}
func (m *ReadStoryVO) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadStoryVO.DiscardUnknown(m)
}

var xxx_messageInfo_ReadStoryVO proto.InternalMessageInfo

func (m *ReadStoryVO) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func (m *ReadStoryVO) GetTutorName() string {
	if m != nil {
		return m.TutorName
	}
	return ""
}

func (m *ReadStoryVO) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type RequestReadStory struct {
	Course               string   `protobuf:"bytes,1,opt,name=course,proto3" json:"course,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestReadStory) Reset()         { *m = RequestReadStory{} }
func (m *RequestReadStory) String() string { return proto.CompactTextString(m) }
func (*RequestReadStory) ProtoMessage()    {}
func (*RequestReadStory) Descriptor() ([]byte, []int) {
	return fileDescriptor_725931738025df9a, []int{1}
}

func (m *RequestReadStory) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestReadStory.Unmarshal(m, b)
}
func (m *RequestReadStory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestReadStory.Marshal(b, m, deterministic)
}
func (m *RequestReadStory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestReadStory.Merge(m, src)
}
func (m *RequestReadStory) XXX_Size() int {
	return xxx_messageInfo_RequestReadStory.Size(m)
}
func (m *RequestReadStory) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestReadStory.DiscardUnknown(m)
}

var xxx_messageInfo_RequestReadStory proto.InternalMessageInfo

func (m *RequestReadStory) GetCourse() string {
	if m != nil {
		return m.Course
	}
	return ""
}

func init() {
	proto.RegisterType((*ReadStoryVO)(nil), "streamexp.ReadStoryVO")
	proto.RegisterType((*RequestReadStory)(nil), "streamexp.RequestReadStory")
}

func init() { proto.RegisterFile("readmystory.proto", fileDescriptor_725931738025df9a) }

var fileDescriptor_725931738025df9a = []byte{
	// 220 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2c, 0x4a, 0x4d, 0x4c,
	0xc9, 0xad, 0x2c, 0x2e, 0xc9, 0x2f, 0xaa, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x2c,
	0x2e, 0x29, 0x4a, 0x4d, 0xcc, 0x4d, 0xad, 0x28, 0x50, 0x8a, 0xe6, 0xe2, 0x0e, 0x4a, 0x4d, 0x4c,
	0x09, 0x06, 0xc9, 0x86, 0xf9, 0x0b, 0x89, 0x71, 0xb1, 0x25, 0xe7, 0x97, 0x16, 0x15, 0xa7, 0x4a,
	0x30, 0x2a, 0x30, 0x6a, 0x70, 0x06, 0x41, 0x79, 0x42, 0x32, 0x5c, 0x9c, 0x25, 0xa5, 0x25, 0xf9,
	0x45, 0x7e, 0x89, 0xb9, 0xa9, 0x12, 0x4c, 0x60, 0x29, 0x84, 0x00, 0x48, 0x57, 0x71, 0x49, 0x62,
	0x49, 0x69, 0xb1, 0x04, 0xb3, 0x02, 0xa3, 0x06, 0x47, 0x10, 0x94, 0xa7, 0xa4, 0xc5, 0x25, 0x10,
	0x94, 0x5a, 0x58, 0x9a, 0x5a, 0x5c, 0x02, 0xb7, 0x03, 0x97, 0x0d, 0x46, 0xcb, 0x99, 0xb8, 0x84,
	0x40, 0xaa, 0x7c, 0x2b, 0xc1, 0xea, 0x82, 0x53, 0x8b, 0xca, 0x32, 0x93, 0x53, 0x85, 0xec, 0xb9,
	0x38, 0xdc, 0x53, 0x4b, 0x20, 0x5a, 0xa5, 0xf5, 0xe0, 0xee, 0xd6, 0x43, 0x37, 0x57, 0x4a, 0x0c,
	0x45, 0x12, 0xe1, 0x23, 0x17, 0x2e, 0x6e, 0x9f, 0xcc, 0xe2, 0x12, 0xff, 0x34, 0xf2, 0xcd, 0x30,
	0x60, 0x04, 0x99, 0x02, 0x71, 0x16, 0xd8, 0x63, 0x64, 0x99, 0xa2, 0x01, 0x32, 0x85, 0xd3, 0xad,
	0x34, 0x27, 0x87, 0x7c, 0x97, 0x68, 0x30, 0x1a, 0x30, 0x26, 0xb1, 0x81, 0x23, 0xd1, 0x18, 0x10,
	0x00, 0x00, 0xff, 0xff, 0x65, 0xaf, 0x0b, 0x5b, 0xd9, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ReadMyStoryServiceClient is the client API for ReadMyStoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReadMyStoryServiceClient interface {
	GetStory(ctx context.Context, in *RequestReadStory, opts ...grpc.CallOption) (*ReadStoryVO, error)
	ListOfStory(ctx context.Context, in *RequestReadStory, opts ...grpc.CallOption) (ReadMyStoryService_ListOfStoryClient, error)
	StoryStatus(ctx context.Context, opts ...grpc.CallOption) (ReadMyStoryService_StoryStatusClient, error)
	FullStory(ctx context.Context, opts ...grpc.CallOption) (ReadMyStoryService_FullStoryClient, error)
}

type readMyStoryServiceClient struct {
	cc *grpc.ClientConn
}

func NewReadMyStoryServiceClient(cc *grpc.ClientConn) ReadMyStoryServiceClient {
	return &readMyStoryServiceClient{cc}
}

func (c *readMyStoryServiceClient) GetStory(ctx context.Context, in *RequestReadStory, opts ...grpc.CallOption) (*ReadStoryVO, error) {
	out := new(ReadStoryVO)
	err := c.cc.Invoke(ctx, "/streamexp.ReadMyStoryService/GetStory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readMyStoryServiceClient) ListOfStory(ctx context.Context, in *RequestReadStory, opts ...grpc.CallOption) (ReadMyStoryService_ListOfStoryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ReadMyStoryService_serviceDesc.Streams[0], "/streamexp.ReadMyStoryService/ListOfStory", opts...)
	if err != nil {
		return nil, err
	}
	x := &readMyStoryServiceListOfStoryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReadMyStoryService_ListOfStoryClient interface {
	Recv() (*ReadStoryVO, error)
	grpc.ClientStream
}

type readMyStoryServiceListOfStoryClient struct {
	grpc.ClientStream
}

func (x *readMyStoryServiceListOfStoryClient) Recv() (*ReadStoryVO, error) {
	m := new(ReadStoryVO)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *readMyStoryServiceClient) StoryStatus(ctx context.Context, opts ...grpc.CallOption) (ReadMyStoryService_StoryStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ReadMyStoryService_serviceDesc.Streams[1], "/streamexp.ReadMyStoryService/StoryStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &readMyStoryServiceStoryStatusClient{stream}
	return x, nil
}

type ReadMyStoryService_StoryStatusClient interface {
	Send(*RequestReadStory) error
	CloseAndRecv() (*ReadStoryVO, error)
	grpc.ClientStream
}

type readMyStoryServiceStoryStatusClient struct {
	grpc.ClientStream
}

func (x *readMyStoryServiceStoryStatusClient) Send(m *RequestReadStory) error {
	return x.ClientStream.SendMsg(m)
}

func (x *readMyStoryServiceStoryStatusClient) CloseAndRecv() (*ReadStoryVO, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReadStoryVO)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *readMyStoryServiceClient) FullStory(ctx context.Context, opts ...grpc.CallOption) (ReadMyStoryService_FullStoryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ReadMyStoryService_serviceDesc.Streams[2], "/streamexp.ReadMyStoryService/FullStory", opts...)
	if err != nil {
		return nil, err
	}
	x := &readMyStoryServiceFullStoryClient{stream}
	return x, nil
}

type ReadMyStoryService_FullStoryClient interface {
	Send(*RequestReadStory) error
	Recv() (*ReadStoryVO, error)
	grpc.ClientStream
}

type readMyStoryServiceFullStoryClient struct {
	grpc.ClientStream
}

func (x *readMyStoryServiceFullStoryClient) Send(m *RequestReadStory) error {
	return x.ClientStream.SendMsg(m)
}

func (x *readMyStoryServiceFullStoryClient) Recv() (*ReadStoryVO, error) {
	m := new(ReadStoryVO)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ReadMyStoryServiceServer is the server API for ReadMyStoryService service.
type ReadMyStoryServiceServer interface {
	GetStory(context.Context, *RequestReadStory) (*ReadStoryVO, error)
	ListOfStory(*RequestReadStory, ReadMyStoryService_ListOfStoryServer) error
	StoryStatus(ReadMyStoryService_StoryStatusServer) error
	FullStory(ReadMyStoryService_FullStoryServer) error
}

// UnimplementedReadMyStoryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedReadMyStoryServiceServer struct {
}

func (*UnimplementedReadMyStoryServiceServer) GetStory(ctx context.Context, req *RequestReadStory) (*ReadStoryVO, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStory not implemented")
}
func (*UnimplementedReadMyStoryServiceServer) ListOfStory(req *RequestReadStory, srv ReadMyStoryService_ListOfStoryServer) error {
	return status.Errorf(codes.Unimplemented, "method ListOfStory not implemented")
}
func (*UnimplementedReadMyStoryServiceServer) StoryStatus(srv ReadMyStoryService_StoryStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method StoryStatus not implemented")
}
func (*UnimplementedReadMyStoryServiceServer) FullStory(srv ReadMyStoryService_FullStoryServer) error {
	return status.Errorf(codes.Unimplemented, "method FullStory not implemented")
}

func RegisterReadMyStoryServiceServer(s *grpc.Server, srv ReadMyStoryServiceServer) {
	s.RegisterService(&_ReadMyStoryService_serviceDesc, srv)
}

func _ReadMyStoryService_GetStory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReadStory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadMyStoryServiceServer).GetStory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/streamexp.ReadMyStoryService/GetStory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadMyStoryServiceServer).GetStory(ctx, req.(*RequestReadStory))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadMyStoryService_ListOfStory_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RequestReadStory)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReadMyStoryServiceServer).ListOfStory(m, &readMyStoryServiceListOfStoryServer{stream})
}

type ReadMyStoryService_ListOfStoryServer interface {
	Send(*ReadStoryVO) error
	grpc.ServerStream
}

type readMyStoryServiceListOfStoryServer struct {
	grpc.ServerStream
}

func (x *readMyStoryServiceListOfStoryServer) Send(m *ReadStoryVO) error {
	return x.ServerStream.SendMsg(m)
}

func _ReadMyStoryService_StoryStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReadMyStoryServiceServer).StoryStatus(&readMyStoryServiceStoryStatusServer{stream})
}

type ReadMyStoryService_StoryStatusServer interface {
	SendAndClose(*ReadStoryVO) error
	Recv() (*RequestReadStory, error)
	grpc.ServerStream
}

type readMyStoryServiceStoryStatusServer struct {
	grpc.ServerStream
}

func (x *readMyStoryServiceStoryStatusServer) SendAndClose(m *ReadStoryVO) error {
	return x.ServerStream.SendMsg(m)
}

func (x *readMyStoryServiceStoryStatusServer) Recv() (*RequestReadStory, error) {
	m := new(RequestReadStory)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ReadMyStoryService_FullStory_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReadMyStoryServiceServer).FullStory(&readMyStoryServiceFullStoryServer{stream})
}

type ReadMyStoryService_FullStoryServer interface {
	Send(*ReadStoryVO) error
	Recv() (*RequestReadStory, error)
	grpc.ServerStream
}

type readMyStoryServiceFullStoryServer struct {
	grpc.ServerStream
}

func (x *readMyStoryServiceFullStoryServer) Send(m *ReadStoryVO) error {
	return x.ServerStream.SendMsg(m)
}

func (x *readMyStoryServiceFullStoryServer) Recv() (*RequestReadStory, error) {
	m := new(RequestReadStory)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ReadMyStoryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "streamexp.ReadMyStoryService",
	HandlerType: (*ReadMyStoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStory",
			Handler:    _ReadMyStoryService_GetStory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListOfStory",
			Handler:       _ReadMyStoryService_ListOfStory_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StoryStatus",
			Handler:       _ReadMyStoryService_StoryStatus_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FullStory",
			Handler:       _ReadMyStoryService_FullStory_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "readmystory.proto",
}
